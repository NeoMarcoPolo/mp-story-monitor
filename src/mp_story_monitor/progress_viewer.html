<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Pipeline Monitor</title>
  <style>
    :root {
      /* High Contrast Technical Theme */
      --black: #050505;
      --dark-gray: #111111;
      --mid-gray: #333333;
      --light-gray: #e5e5e5;
      --white: #ffffff;

      /* Vibrant Accent */
      --accent: #00ecff;
      /* Cyan/Electric Blue for high visibility against black */
      --accent-dim: rgba(0, 236, 255, 0.1);

      /* Semantic Colors */
      --bg: var(--black);
      --card-bg: var(--dark-gray);
      --border: var(--mid-gray);
      --text-primary: var(--white);
      --text-secondary: #888888;

      --success: #00ff9d;
      --running: var(--accent);
      --pending: #444444;
      --error: #ff0055;

      /* Spacing */
      --space-sm: 0.5rem;
      --space-md: 1rem;
      --space-lg: 1.5rem;
    }

    * {
      box-sizing: border-box;
    }

    body {
      font-family: "SF Mono", "Menlo", "Monaco", "Courier New", monospace;
      /* Technical feel */
      background: var(--bg);
      color: var(--text-primary);
      margin: 0;
      padding: var(--space-lg);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      gap: var(--space-lg);
      font-size: 14px;
      line-height: 1.5;
    }

    /* Layout Grid: sidebar collapses to narrow strip so main area expands */
    .dashboard {
      display: grid;
      grid-template-columns: 300px 1fr;
      gap: var(--space-lg);
      max-width: 1400px;
      margin: 0 auto;
      width: 100%;
      transition: grid-template-columns 0.2s ease;
    }
    .dashboard.sidebar-collapsed {
      grid-template-columns: 48px 1fr;
    }

    .sidebar-column {
      display: flex;
      flex-direction: row;
      min-width: 0;
      background: var(--card-bg);
      border: 1px solid var(--border);
      transition: width 0.2s ease;
    }
    .sidebar-column .sidebar-content {
      flex: 1;
      min-width: 0;
      overflow: auto;
      padding: var(--space-md);
      display: flex;
      flex-direction: column;
      gap: 0;
    }
    .sidebar-column.collapsed .sidebar-content {
      display: none;
    }
    .sidebar-toggle-strip {
      width: 48px;
      min-width: 48px;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      border-left: 1px solid var(--border);
      background: rgba(0, 0, 0, 0.2);
    }
    .sidebar-column.collapsed .sidebar-toggle-strip {
      border-left: none;
      border-right: 1px solid var(--border);
    }
    .sidebar-toggle-btn {
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-secondary);
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 0.9rem;
      font-family: inherit;
      padding: 0;
    }
    .sidebar-toggle-btn:hover {
      border-color: var(--accent);
      color: var(--accent);
    }

    @media (max-width: 900px) {
      .dashboard {
        grid-template-columns: 1fr;
      }
      .dashboard.sidebar-collapsed {
        grid-template-columns: 1fr;
      }
      .sidebar-column.collapsed .sidebar-content {
        display: none;
      }
    }

    /* Header: sticky so pipeline status stays visible when scrolling the table */
    header {
      position: sticky;
      top: 0;
      z-index: 10;
      background: var(--bg);
      display: flex;
      flex-direction: column;
      gap: var(--space-md);
      border-bottom: 1px solid var(--border);
      padding-bottom: var(--space-md);
      margin-bottom: var(--space-md);
      box-shadow: 0 1px 0 var(--border);
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      gap: var(--space-lg);
    }

    .header .title {
      font-size: 2.25rem;
      font-weight: 700;
      letter-spacing: -0.5px;
      text-transform: uppercase;
      margin: 0;
      flex-shrink: 0;
    }

    .header .header-meta {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 0.25rem;
      font-size: 0.8rem;
      color: var(--text-secondary);
    }

    .header .header-meta .meta {
      margin: 0;
    }

    /* Pipeline status in header: horizontal phase list + generating/update info */
    .header-pipeline {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: var(--space-md);
      width: 100%;
      min-height: 2.5rem;
      padding: var(--space-sm) 0;
      border-top: 1px solid var(--border);
      margin-top: 2px;
    }
    .header-pipeline .pipeline-label {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-secondary);
      margin-right: var(--space-sm);
      flex-shrink: 0;
    }
    .header-pipeline .phase-list-inline {
      display: flex;
      flex-direction: row;
      flex-wrap: wrap;
      gap: 0;
      align-items: center;
    }
    .header-pipeline .phase-item {
      padding: var(--space-sm) var(--space-md);
      margin-right: 2px;
    }
    .header-pipeline .phase-item .phase-name {
      margin-right: 0.35rem;
    }
    .header-pipeline .generating-status {
      margin-top: 0;
      margin-left: var(--space-sm);
    }
    .header-pipeline .updated-bar {
      margin-top: 0;
      margin-left: auto;
      font-size: 0.75rem;
    }
    .header-pipeline .pipeline-error-card {
      width: 100%;
      margin-top: var(--space-sm);
    }

    h1 {
      font-size: 1.5rem;
      margin: 0;
      font-weight: 700;
      letter-spacing: -0.5px;
      text-transform: uppercase;
    }

    .meta-camp {
      display: flex;
      gap: var(--space-md);
      font-size: 0.85rem;
      color: var(--text-secondary);
    }

    .meta-item {
      display: flex;
      align-items: center;
      gap: 0.5em;
    }

    .meta-value {
      color: var(--accent);
      font-weight: 600;
    }

    /* Card Consistencies */
    .card {
      background: var(--card-bg);
      border: 1px solid var(--border);
      padding: var(--space-md);
      display: flex;
      flex-direction: column;
    }

    .card-title {
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: var(--text-secondary);
      margin: 0 0 var(--space-md) 0;
      border-bottom: 1px solid var(--border);
      padding-bottom: var(--space-sm);
    }

    /* Sidebar content sections (no per-panel collapse; only whole sidebar collapses to left) */
    .sidebar-content .card {
      margin-bottom: var(--space-lg);
    }
    .sidebar-content .card:last-child {
      margin-bottom: 0;
    }

    /* Phases Stepper */
    .phase-list {
      display: flex;
      flex-direction: column;
      gap: 0;
    }

    .phase-item {
      display: flex;
      align-items: center;
      padding: var(--space-sm) var(--space-md);
      border: 1px solid var(--border);
      position: relative;
      background: transparent;
      transition: background 0.2s;
    }

    .phase-item:hover {
      background: rgba(255, 255, 255, 0.03);
    }

    .phase-item.running {
      border-color: var(--running);
      background: var(--accent-dim);
    }

    .phase-item.done {
      border-color: var(--success);
    }

    .phase-item.pending {
      border-color: var(--pending);
      color: var(--text-secondary);
    }

    .phase-icon {
      margin-right: var(--space-md);
      font-weight: bold;
      width: 1.5em;
      text-align: center;
    }

    .phase-name {
      font-weight: 600;
      flex: 1;
    }

    .phase-status {
      font-size: 0.75rem;
      text-transform: uppercase;
      padding: 2px 6px;
      font-weight: bold;
    }

    .status-badge {
      display: inline-block;
      padding: 2px 6px;
      font-size: 0.7rem;
      font-weight: 700;
      text-transform: uppercase;
      border: 1px solid currentColor;
    }

    .status-badge.running {
      color: var(--running);
      border-color: var(--running);
      box-shadow: 0 0 5px var(--running);
    }

    .status-badge.done {
      color: var(--success);
      border-color: var(--success);
    }

    .status-badge.pending {
      color: var(--text-secondary);
      border-color: var(--border);
    }

    .status-badge.error {
      color: var(--error);
      border-color: var(--error);
    }

    .copy-error-btn {
      background: transparent;
      border: 1px solid var(--error);
      color: var(--error);
      padding: 4px 8px;
      font-family: inherit;
      font-size: 0.75rem;
      cursor: pointer;
      text-transform: uppercase;
      flex-shrink: 0;
    }
    .copy-error-btn:hover {
      opacity: 0.9;
    }
    .pipeline-error-card .pipeline-error-summary {
      font-weight: 600;
      color: var(--error);
      margin-bottom: 0.5rem;
    }
    .pipeline-traceback {
      font-size: 0.75rem;
      font-family: ui-monospace, monospace;
      background: rgba(0,0,0,0.3);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 0.75rem;
      margin: 0;
      max-height: 280px;
      overflow: auto;
      white-space: pre-wrap;
      word-break: break-all;
      color: #ccc;
    }

    /* Story Dashboard */
    .story-title-large {
      font-size: 1.75rem;
      font-weight: 800;
      margin: 0 0 var(--space-sm) 0;
      line-height: 1.2;
    }

    .logline {
      font-size: 1rem;
      color: var(--text-secondary);
      margin-bottom: var(--space-lg);
      font-style: italic;
      border: 1px solid var(--accent);
      padding: var(--space-md);
    }

    /* Asset Grid */
    .asset-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 1px;
      /* Gap for border effect */
      background: var(--border);
      border: 1px solid var(--border);
      margin-bottom: var(--space-lg);
    }

    .asset-stat {
      background: var(--card-bg);
      padding: var(--space-md);
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
    }

    .asset-shape-wrap {
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Shape: Image = rectangle (frame) */
    .asset-shape-image {
      width: 28px;
      height: 20px;
      border: 1px solid currentColor;
      border-radius: 2px;
      background: transparent;
    }

    /* Shape: Video = rectangle with play triangle */
    .asset-shape-video {
      width: 28px;
      height: 20px;
      border: 1px solid currentColor;
      border-radius: 2px;
      background: transparent;
      position: relative;
    }

    .asset-shape-video::after {
      content: "";
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-40%, -50%);
      border-width: 6px 0 6px 10px;
      border-style: solid;
      border-color: transparent transparent transparent currentColor;
    }

    /* Shape: Audio = 3 bars (waveform) */
    .asset-shape-audio {
      display: flex;
      align-items: flex-end;
      gap: 3px;
      height: 20px;
    }

    .asset-shape-audio span {
      width: 4px;
      background: currentColor;
      border-radius: 1px;
    }

    .asset-shape-audio span:nth-child(1) {
      height: 10px;
    }

    .asset-shape-audio span:nth-child(2) {
      height: 18px;
    }

    .asset-shape-audio span:nth-child(3) {
      height: 14px;
    }

    /* Shape: Text = 3 lines (document) */
    .asset-shape-text {
      width: 24px;
      height: 20px;
      display: flex;
      flex-direction: column;
      gap: 3px;
      justify-content: center;
    }

    .asset-shape-text span {
      height: 2px;
      background: currentColor;
      border-radius: 1px;
    }

    .asset-shape-text span:nth-child(1) {
      width: 100%;
    }

    .asset-shape-text span:nth-child(2) {
      width: 85%;
    }

    .asset-shape-text span:nth-child(3) {
      width: 70%;
    }

    .asset-val {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--text-primary);
      display: block;
    }

    .asset-label {
      font-size: 0.75rem;
      text-transform: uppercase;
      color: var(--text-secondary);
      margin-top: 0;
      display: block;
    }

    /* Chapters List */
    .chapter-list {
      display: flex;
      flex-direction: column;
      gap: var(--space-md);
    }

    .chapter-block {
      border: 1px solid var(--border);
      background: var(--bg);
    }

    .chapter-header {
      padding: var(--space-sm) var(--space-md);
      background: rgba(255, 255, 255, 0.05);
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .chapter-title {
      font-weight: 700;
      font-size: 0.95rem;
    }

    .scene-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9rem;
    }

    .scene-table th,
    .scene-table td {
      padding: var(--space-sm) var(--space-md);
      text-align: left;
      border-bottom: 1px solid var(--border);
    }

    .scene-table tr:last-child td {
      border-bottom: none;
    }

    .scene-table th {
      color: var(--text-secondary);
      font-weight: 400;
      font-size: 0.75rem;
      text-transform: uppercase;
      border-bottom: 1px solid var(--border);
    }

    .scene-assets-cell {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      align-items: center;
    }

    .mini-badge {
      font-size: 0.7rem;
      padding: 2px 6px;
      border: 1px solid var(--border);
      color: var(--text-secondary);
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .mini-badge.has-assets {
      border-color: var(--accent);
      color: var(--accent);
    }

    /* Inline shapes for scene badges (small) */
    .mini-badge .asset-shape-image {
      width: 14px;
      height: 10px;
      border-width: 1px;
    }

    .mini-badge .asset-shape-video {
      width: 14px;
      height: 10px;
      border-width: 1px;
    }

    .mini-badge .asset-shape-video::after {
      border-width: 3px 0 3px 5px;
    }

    .mini-badge .asset-shape-audio {
      height: 10px;
    }

    .mini-badge .asset-shape-audio span {
      width: 2px;
    }

    .mini-badge .asset-shape-audio span:nth-child(1) {
      height: 5px;
    }

    .mini-badge .asset-shape-audio span:nth-child(2) {
      height: 9px;
    }

    .mini-badge .asset-shape-audio span:nth-child(3) {
      height: 7px;
    }

    .mini-badge .asset-shape-text {
      width: 12px;
      height: 10px;
      gap: 1px;
    }

    .mini-badge .asset-shape-text span {
      height: 1px;
    }

    .mini-badge .asset-shape-text span:nth-child(2) {
      width: 80%;
    }

    .mini-badge .asset-shape-text span:nth-child(3) {
      width: 60%;
    }

    /* Utilities */
    .spinner {
      display: inline-block;
      animation: spin 1s steps(8) infinite;
    }

    @keyframes spin {
      100% {
        transform: rotate(360deg);
      }
    }

    .blink {
      animation: blink 1s step-end infinite;
    }

    @keyframes blink {
      50% {
        opacity: 0;
      }
    }

    .text-mono {
      font-family: monospace;
    }

    .text-dim {
      color: var(--text-secondary);
    }

    .text-accent {
      color: var(--accent);
    }

    .updated-bar {
      font-size: 0.75rem;
      color: var(--text-secondary);
      margin-top: var(--space-sm);
      text-align: right;
    }

    .updated-bar.stale {
      color: var(--error);
      font-weight: 700;
      animation: pulse-stale 1.5s ease-in-out infinite;
    }

    @keyframes pulse-stale {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.75;
      }
    }

    .generating-status {
      margin-top: var(--space-sm);
      font-size: 0.8rem;
      min-height: 1.5em;
    }

    .generating-status .generating-line {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      color: var(--running);
      font-weight: 600;
      animation: generating-pulse 2s ease-in-out infinite;
    }

    @keyframes generating-pulse {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.85;
      }
    }

    .generating-status .generating-line .spinner {
      display: inline-block;
      font-size: 1.1em;
    }

    .generating-status .updated-hint {
      display: block;
      margin-top: 4px;
      font-size: 0.75rem;
      color: var(--text-secondary);
    }

    .generating-status .stale-warning {
      display: block;
      margin-top: 6px;
      color: var(--error);
      font-weight: 600;
    }

    /* Main card pulse when a phase is generating */
    .card.phase-generating {
      position: relative;
      border-top: 2px solid var(--running);
      animation: card-pulse 2s ease-in-out infinite;
    }

    @keyframes card-pulse {

      0%,
      100% {
        box-shadow: 0 0 0 0 rgba(0, 236, 255, 0);
      }

      50% {
        box-shadow: 0 0 12px 0 rgba(0, 236, 255, 0.25);
      }
    }

    @keyframes pulse-border {
      0% {
        border-color: var(--running);
        background: var(--accent-dim);
      }

      50% {
        border-color: transparent;
        background: transparent;
      }

      100% {
        border-color: var(--running);
        background: var(--accent-dim);
      }
    }

    .blink-border {
      animation: pulse-border 2s infinite;
    }

    /* Story building in progress ‚Äî inform user */
    .story-building-info {
      display: none;
      align-items: center;
      gap: var(--space-md);
      padding: var(--space-sm) var(--space-md);
      margin-bottom: var(--space-md);
      background: var(--accent-dim);
      border: 1px solid var(--running);
      color: var(--running);
      font-size: 0.85rem;
      font-weight: 600;
    }
    .story-building-info.visible {
      display: flex;
    }
    .story-building-info .spinner {
      flex-shrink: 0;
    }

    .mute-toggle {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-secondary);
      font-family: inherit;
      font-size: 0.75rem;
      padding: 4px 8px;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .mute-toggle:hover {
      border-color: var(--accent);
      color: var(--accent);
    }
    .mute-toggle.muted {
      border-color: var(--error);
      color: var(--error);
    }

    /* --- CINEMA MODE / SCREENPLAY STYLING --- */
    .screenplay-container {
      font-family: "Courier Prime", "Courier New", Courier, monospace;
      background: #1a1a1a;
      padding: var(--space-lg);
      border: 1px solid #333;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
      color: #ddd;
      width: 100%;
      min-width: 0;
    }

    .sp-slugline {
      font-weight: bold;
      text-transform: uppercase;
      margin-top: 1.5rem;
      margin-bottom: 0.5rem;
      color: var(--white);
      border-bottom: 1px solid #333;
      padding-bottom: 4px;
    }

    .sp-action {
      margin-bottom: 1rem;
      line-height: 1.4;
    }

    .sp-character {
      text-align: center;
      font-weight: bold;
      margin-top: 1rem;
      margin-bottom: 0px;
      width: 60%;
      margin-left: auto;
      margin-right: auto;
      text-transform: uppercase;
    }

    .sp-dialogue {
      text-align: center;
      width: 80%;
      margin-left: auto;
      margin-right: auto;
      margin-bottom: 1rem;
    }

    .sp-transition {
      text-align: right;
      text-transform: uppercase;
      margin-top: 1rem;
      margin-bottom: 1rem;
      font-size: 0.9rem;
    }

    /* Shot List / Asset Details */
    .shot-list {
      margin-top: 1rem;
      border-top: 1px dashed #333;
      padding-top: 0.5rem;
      font-family: "SF Mono", "Menlo", monospace;
      font-size: 0.8rem;
      overflow-x: auto;
    }

    .shot-item {
      display: grid;
      grid-template-columns: 24px 1fr auto;
      grid-template-rows: auto auto auto;
      gap: var(--space-sm);
      padding: 4px 0;
      align-items: start;
      border-bottom: 1px solid #222;
      color: #888;
    }
    .shot-item .shot-icon { grid-column: 1; grid-row: 1; }
    .shot-item .shot-meta:first-of-type { grid-column: 2; grid-row: 1; min-width: 0; word-break: break-word; }
    .shot-item .shot-meta:last-of-type { grid-column: 3; grid-row: 1; }
    .shot-item .shot-reason { grid-column: 1 / -1; grid-row: 2; min-width: 0; margin-top: 2px; text-transform: none; }
    .shot-item .shot-prompt { grid-column: 1 / -1; grid-row: 3; min-width: 0; margin-top: 2px; }

    .shot-item:last-child {
      border-bottom: none;
    }

    /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
       ASSET TABLE ‚Äî Mission Control Console
       ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
    .assets-table {
      width: 100%;
      min-width: 900px;
      border-collapse: separate;
      border-spacing: 0 2px;
      font-size: 0.82rem;
      margin-top: 0.75rem;
      table-layout: fixed;
    }

    /* Header row */
    .assets-table thead tr {
      background: linear-gradient(180deg, rgba(0, 236, 255, 0.06) 0%, transparent 100%);
    }
    .assets-table th {
      text-align: left;
      padding: 0.6rem 0.75rem;
      vertical-align: middle;
      border-bottom: 1px solid rgba(0, 236, 255, 0.15);
      color: rgba(0, 236, 255, 0.6);
      font-weight: 700;
      text-transform: uppercase;
      font-size: 0.65rem;
      letter-spacing: 0.12em;
    }

    /* Body rows */
    .assets-table td {
      padding: 0.6rem 0.75rem;
      vertical-align: top;
      color: #bbb;
      border-bottom: 1px solid rgba(255, 255, 255, 0.04);
      transition: background 0.15s ease;
    }
    .assets-table td[title] { cursor: help; }
    .assets-table tbody tr {
      background: rgba(255, 255, 255, 0.015);
      border-left: 2px solid transparent;
      transition: all 0.15s ease;
    }
    .assets-table tbody tr:hover {
      background: rgba(0, 236, 255, 0.03);
      border-left-color: rgba(0, 236, 255, 0.3);
    }
    .assets-table tbody tr:hover td:first-child {
      box-shadow: inset 2px 0 0 var(--accent);
    }
    .assets-table tr:last-child td { border-bottom: none; }

    /* ‚îÄ‚îÄ NAME column ‚îÄ‚îÄ */
    .assets-table th.col-name { padding-left: 2.5rem; }
    .assets-table .col-name {
      width: 22%;
      min-width: 140px;
      vertical-align: top;
    }
    .assets-table .col-name .name-inner {
      display: flex;
      align-items: flex-start;
      gap: 8px;
    }
    .assets-table .col-name .shot-icon {
      flex-shrink: 0;
      width: 26px;
      height: 26px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 236, 255, 0.08);
      border-radius: 5px;
      border: 1px solid rgba(0, 236, 255, 0.15);
      color: var(--accent);
      margin-top: 1px;
      transform: scale(0.78);
    }
    .assets-table .col-name .name-inner > span {
      color: var(--accent);
      font-weight: 600;
      overflow: hidden;
      text-overflow: ellipsis;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      line-clamp: 2;
      line-height: 1.4;
      word-break: break-word;
      overflow-wrap: break-word;
      font-size: 0.8rem;
      letter-spacing: 0.01em;
    }

    /* ‚îÄ‚îÄ WORKFLOW column ‚îÄ‚îÄ */
    .assets-table .col-workflow {
      width: 14%;
      font-size: 0.72rem;
    }
    .assets-table .col-workflow .workflow-id {
      display: inline-block;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 3px;
      padding: 2px 6px;
      font-family: ui-monospace, "Cascadia Code", "SF Mono", monospace;
      color: #999;
      max-width: 100%;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    /* ‚îÄ‚îÄ WHY column ‚îÄ‚îÄ */
    .assets-table .col-why {
      width: 18%;
      font-size: 0.78rem;
      color: #7a9a85;
      line-height: 1.45;
    }
    .asset-cell-truncate {
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      line-clamp: 2;
      overflow: hidden;
      text-overflow: ellipsis;
      word-break: break-word;
      line-height: 1.4;
    }

    /* ‚îÄ‚îÄ METADATA column ‚îÄ‚îÄ */
    .assets-table .col-meta {
      width: 23%;
    }
    .assets-table .col-meta .shot-prompt {
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      line-clamp: 2;
      overflow: hidden;
      text-overflow: ellipsis;
      word-break: break-word;
      line-height: 1.4;
      max-height: 2.9em;
      font-size: 0.75rem;
    }

    /* ‚îÄ‚îÄ STATUS column ‚îÄ‚îÄ */
    .assets-table .col-status {
      width: 10%;
      min-width: 5.5rem;
      text-align: right;
      vertical-align: top;
      padding-top: 0.65rem;
    }
    .status-badge {
      display: inline-block;
      font-size: 0.65rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      padding: 3px 8px;
      border-radius: 3px;
      line-height: 1;
    }
    .status-badge.s-pending {
      background: rgba(255, 255, 255, 0.05);
      color: #555;
      border: 1px solid rgba(255, 255, 255, 0.08);
    }
    .status-badge.s-complete, .status-badge.s-success {
      background: rgba(0, 255, 157, 0.08);
      color: var(--success);
      border: 1px solid rgba(0, 255, 157, 0.2);
    }
    .status-badge.s-running, .status-badge.s-generating {
      background: rgba(0, 236, 255, 0.08);
      color: var(--accent);
      border: 1px solid rgba(0, 236, 255, 0.25);
      animation: statusPulse 2s ease-in-out infinite;
    }
    .status-badge.s-failed, .status-badge.s-error {
      background: rgba(255, 0, 85, 0.1);
      color: var(--error);
      border: 1px solid rgba(255, 0, 85, 0.25);
    }
    @keyframes statusPulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    /* ‚îÄ‚îÄ OUTPUT column ‚îÄ‚îÄ */
    .assets-table .col-output {
      width: 10%;
      min-width: 6rem;
      text-align: center;
    }
    .assets-table .col-output img,
    .assets-table .col-output video {
      border-radius: 4px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      transition: transform 0.15s ease;
    }
    .assets-table .col-output img:hover,
    .assets-table .col-output video:hover {
      transform: scale(1.05);
      border-color: rgba(0, 236, 255, 0.3);
    }

    /* ‚îÄ‚îÄ EXPAND column ‚îÄ‚îÄ */
    .assets-table .col-expand {
      width: 3%;
      min-width: 2rem;
      max-width: 2.5rem;
      padding: 0.4rem 0.35rem;
      text-align: center;
      vertical-align: top;
    }
    .row-expand-btn {
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.08);
      color: #555;
      font-size: 0.7rem;
      font-weight: 700;
      width: 22px;
      height: 22px;
      padding: 0;
      line-height: 1;
      cursor: pointer;
      border-radius: 3px;
      font-family: inherit;
      transition: all 0.12s ease;
    }
    .row-expand-btn:hover {
      background: rgba(0, 236, 255, 0.08);
      border-color: rgba(0, 236, 255, 0.3);
      color: var(--accent);
    }

    /* ‚îÄ‚îÄ Expanded row state ‚îÄ‚îÄ */
    .assets-table tbody tr.row-expanded {
      background: rgba(0, 236, 255, 0.02);
    }
    .assets-table tbody tr.row-expanded td:first-child {
      box-shadow: inset 2px 0 0 var(--accent);
    }
    .assets-table tbody tr.row-expanded .col-name {
      white-space: normal;
      overflow: visible;
      text-overflow: clip;
      max-width: none;
      word-break: break-word;
    }
    .assets-table tbody tr.row-expanded .col-name > span,
    .assets-table tbody tr.row-expanded .col-name .name-inner > span {
      overflow: visible;
      text-overflow: clip;
      -webkit-line-clamp: unset;
      line-clamp: unset;
    }
    .assets-table tbody tr.row-expanded .col-workflow .workflow-id {
      white-space: normal;
      overflow: visible;
      text-overflow: clip;
      word-break: break-word;
    }
    .assets-table tbody tr.row-expanded .col-why { max-width: none; }
    .assets-table tbody tr.row-expanded .asset-cell-truncate {
      display: block;
      -webkit-line-clamp: unset;
      line-clamp: unset;
      overflow: visible;
      max-height: none;
    }
    .assets-table tbody tr.row-expanded .col-meta .shot-prompt {
      display: block;
      -webkit-line-clamp: unset;
      line-clamp: unset;
      overflow: visible;
      max-height: none;
    }

    .shot-prompt {
      color: #ddd;
      white-space: pre-wrap;
    }

    .shot-meta {
      font-size: 0.7rem;
      text-transform: uppercase;
      opacity: 0.7;
    }

    .toggle-shots-btn {
      background: rgba(0, 236, 255, 0.04);
      border: 1px solid rgba(0, 236, 255, 0.15);
      color: var(--accent);
      font-family: inherit;
      font-size: 0.7rem;
      cursor: pointer;
      padding: 4px 12px;
      margin-top: 0.6rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      border-radius: 3px;
      font-weight: 600;
      transition: all 0.12s ease;
    }

    .toggle-shots-btn:hover {
      background: rgba(0, 236, 255, 0.1);
      border-color: rgba(0, 236, 255, 0.35);
    }

    /* DEBUG mode banner at top of story area */
    .debug-banner {
      background: var(--accent-dim);
      border: 1px solid var(--accent);
      color: var(--accent);
      padding: var(--space-md);
      margin-bottom: var(--space-lg);
      font-size: 0.9rem;
      border-radius: 4px;
    }
    .debug-banner strong { margin-right: 0.5rem; }

    /* Screenplay chapter title: clear "Chapter NN: Title" format, larger font */
    .screenplay-chapter-title {
      font-size: 1.35rem;
      font-weight: 800;
      margin: 2rem 0 1rem 0;
      text-align: left;
      text-transform: none;
      letter-spacing: 0.02em;
      color: var(--text-primary);
      border-bottom: 2px solid var(--border);
      padding-bottom: 0.5rem;
    }

    /* Chapter block in screenplay (wrapper for title + scenes) */
    .screenplay-chapter {
      margin-bottom: 2rem;
    }

    /* Animation when this chapter is being worked on */
    .screenplay-chapter.chapter-working {
      position: relative;
      border: 1px solid var(--running);
      padding: var(--space-md);
      animation: chapter-working-pulse 2s ease-in-out infinite;
    }

    .screenplay-chapter.chapter-working .screenplay-chapter-title {
      color: var(--running);
    }

    .screenplay-chapter.chapter-working .chapter-working-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 0.75rem;
      font-weight: 700;
      text-transform: uppercase;
      color: var(--running);
      margin-left: 0.5rem;
      vertical-align: middle;
    }

    @keyframes chapter-working-pulse {
      0%, 100% { opacity: 1; box-shadow: none; }
      50% { opacity: 0.92; box-shadow: 0 0 0 1px rgba(0, 236, 255, 0.2); }
    }

    /* Scene block wrapper */
    .screenplay-scene {
      margin-top: 1rem;
      padding-left: 0;
      transition: border-color 0.2s, background 0.2s;
    }

    /* Animation when this scene is being worked on (has pending/running assets) */
    .screenplay-scene.scene-working {
      position: relative;
      border: 1px solid var(--running);
      padding: var(--space-md);
      background: rgba(0, 236, 255, 0.04);
      border-radius: 2px;
      animation: scene-working-pulse 2s ease-in-out infinite;
    }

    .screenplay-scene.scene-working .sp-slugline {
      color: var(--running);
    }

    .screenplay-scene .scene-working-badge {
      display: none;
      align-items: center;
      gap: 4px;
      font-size: 0.7rem;
      font-weight: 700;
      text-transform: uppercase;
      color: var(--running);
      margin-left: 0.5rem;
    }

    .screenplay-scene.scene-working .scene-working-badge {
      display: inline-flex;
    }

    @keyframes scene-working-pulse {
      0%, 100% { opacity: 1; background-color: rgba(0, 236, 255, 0.04); }
      50% { opacity: 0.98; background-color: rgba(0, 236, 255, 0.08); }
    }

    /* ‚îÄ‚îÄ Lightbox overlay for enlarged previews ‚îÄ‚îÄ */
    .preview-lightbox {
      position: fixed;
      inset: 0;
      z-index: 99999;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(6px);
      cursor: zoom-out;
    }
    .preview-lightbox img,
    .preview-lightbox video {
      max-width: 90vw;
      max-height: 90vh;
      object-fit: contain;
      border-radius: 8px;
      box-shadow: 0 0 40px rgba(0, 0, 0, 0.6);
    }
    .preview-lightbox audio {
      width: min(80vw, 500px);
    }
    .preview-lightbox .lightbox-close {
      position: absolute;
      top: 16px;
      right: 16px;
      background: rgba(0, 0, 0, 0.5);
      border: none;
      color: #fff;
      font-size: 24px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.15s;
    }
    .preview-lightbox .lightbox-close:hover {
      background: rgba(0, 0, 0, 0.7);
    }
    .assets-table .col-output img,
    .assets-table .col-output video {
      cursor: zoom-in;
    }
  </style>
</head>

<body>

  <header>
    <div class="header">
      <div class="title">MP STORY MONITOR</div>
      <div class="header-meta">
        <button type="button" id="muteToggle" class="mute-toggle" title="Toggle notification sounds" aria-pressed="false">üîä Sound on</button>
        <div class="meta" id="jobId">Job: ...</div>
        <div class="meta" id="workflowName">Workflow: ...</div>
        <div class="meta" id="headerUpdated">Updated: ...</div>
        <div class="meta" id="pipelinePid" style="display: none;" title="Pipeline process ID ‚Äî use 'ps -p &lt;PID&gt;' to check if still running">PID: --</div>
      </div>
    </div>
    <div class="header-pipeline" role="region" aria-label="Pipeline status">
      <span class="pipeline-label">Pipeline</span>
      <div id="phasesList" class="phase-list phase-list-inline">
        <div class="phase-item pending">Loading...</div>
      </div>
      <div id="lastUpdated" class="updated-bar"></div>
      <div id="generatingStatus" class="generating-status"></div>
      <div id="storyBuildTime" class="updated-bar" style="display: none;"></div>
      <div id="pipelineErrorCard" class="pipeline-error-card" style="display: none; padding: var(--space-md); border: 1px solid var(--error); border-radius: 0;">
        <div style="color: var(--error); display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 8px; margin-bottom: var(--space-sm);">
          <span style="font-weight: 600;">Pipeline error</span>
          <button id="copyErrorBtn" type="button" class="copy-error-btn" title="Copy error and traceback to clipboard">Copy error</button>
        </div>
        <div id="pipelineErrorSummary" class="pipeline-error-summary"></div>
        <pre id="pipelineTraceback" class="pipeline-traceback"></pre>
      </div>
    </div>
  </header>

  <div class="dashboard sidebar-collapsed" id="dashboard">
    <!-- Sidebar: collapses to narrow left strip so main area expands; collapsed by default; auto-expand on error -->
    <aside id="sidebarColumn" class="sidebar-column collapsed" aria-label="Output folder and system info">
      <div class="sidebar-content">
      <div class="card">
        <div class="card-title">Output Folder</div>
        <div style="font-size: 0.8rem; word-break: break-all; color: var(--text-secondary); margin-bottom: var(--space-sm);">
          <code id="outputPath" style="user-select: all; cursor: pointer;" title="Click to copy">--</code>
        </div>
        <button id="copyPathBtn"
          style="background: transparent; border: 1px solid var(--accent); color: var(--accent); padding: 4px 8px; font-family: inherit; font-size: 0.75rem; cursor: pointer; text-transform: uppercase;">Copy Path</button>
      </div>

      <div class="card">
        <div class="card-title">System Status</div>
        <div style="font-size: 0.8rem; color: var(--text-secondary);">
          Server: <span id="connectionStatus" style="color: var(--success);">--</span><br>
          <br>
          <div style="font-size: 0.7rem; opacity: 0.7;">
            Refreshes every 2s<br>
            Run: <code>python -m http.server</code> in story folder to view.
          </div>
        </div>
      </div>
      </div>
      <div class="sidebar-toggle-strip">
        <button type="button" id="sidebarToggleBtn" class="sidebar-toggle-btn" title="Expand sidebar (collapse to expand main area)" aria-label="Expand sidebar">‚ñ∂</button>
      </div>
    </aside>

    <!-- Main Content: Application State -->
    <main id="mainContent">
      <div class="card">
        <div class="card-title">Story Intelligence</div>
        <div id="storyBuildingInfo" class="story-building-info" role="status" aria-live="polite">
          <span class="spinner">‚óê</span>
          <span id="storyBuildingInfoText">Story building in progress ‚Äî chapters, scenes and assets are being generated. Page auto-refreshes every 2s.</span>
        </div>
        <div id="storyBoard">
          <div style="padding: var(--space-lg); text-align: center; color: var(--text-secondary);">
            <span class="spinner">/</span> Waiting for data...
          </div>
        </div>
      </div>
    </main>
  </div>

  <script>
    const els = {
      phases: document.getElementById("phasesList"),
      jobId: document.getElementById("jobId"),
      workflowName: document.getElementById("workflowName"),
      updated: document.getElementById("lastUpdated"),
      generatingStatus: document.getElementById("generatingStatus"),
      storyBuildTime: document.getElementById("storyBuildTime"),
      storyBoard: document.getElementById("storyBoard"),
      storyBuildingInfo: document.getElementById("storyBuildingInfo"),
      conn: document.getElementById("connectionStatus"),
      outPath: document.getElementById("outputPath"),
      copyBtn: document.getElementById("copyPathBtn"),
      pipelinePid: document.getElementById("pipelinePid"),
      pipelineErrorCard: document.getElementById("pipelineErrorCard"),
      pipelineErrorSummary: document.getElementById("pipelineErrorSummary"),
      pipelineTraceback: document.getElementById("pipelineTraceback"),
      copyErrorBtn: document.getElementById("copyErrorBtn")
    };

    function escapeHtml(s) {
      if (!s) return "";
      return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
    }
    /** Escape for HTML attribute value (e.g. src). */
    function escapeAttr(s) {
      if (!s) return "";
      return String(s).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#039;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }

    /** Format a param value for display. For dialogue_script, normalize literal \\n to line breaks so dialogue reads clearly. */
    function formatParamValue(key, v) {
      const val = (typeof v === "object") ? JSON.stringify(v) : String(v);
      const isDialogue = key === "dialogue_script" || (typeof v === "string" && /\[S1\]|\[S2\]/.test(v));
      const normalized = isDialogue ? val.replace(/\\n/g, "\n") : val;
      const escaped = escapeHtml(normalized);
      const withBreaks = isDialogue ? escaped.replace(/\n/g, "<br>") : escaped;
      return { html: withBreaks, isBlock: isDialogue };
    }

    /** Returns HTML for the shape icon of an asset type (image, video, audio, text). */
    function shapeHtml(type) {
      const t = (type || "").toLowerCase();
      if (t === "image") return '<div class="asset-shape-image"></div>';
      if (t === "video") return '<div class="asset-shape-video"></div>';
      if (t === "audio") return '<div class="asset-shape-audio"><span></span><span></span><span></span></div>';
      if (t === "text") return '<div class="asset-shape-text"><span></span><span></span><span></span></div>';
      return "";
    }

    function statusBadgeHtml(status) {
      const s = (status || "pending").toLowerCase().replace(/[^a-z]/g, "");
      const cls = s.includes("complete") || s === "success" ? "s-complete"
        : s === "running" || s === "generating" ? "s-running"
        : s === "failed" || s === "error" ? "s-failed"
        : "s-pending";
      return `<span class="status-badge ${cls}">${escapeHtml(status)}</span>`;
    }

    function formatTimeAgo(ts) {
      if (!ts) return "";
      const t = new Date(ts).getTime();
      const s = Math.round((Date.now() - t) / 1000);
      return s < 60 ? `${s}s ago` : `${Math.floor(s / 60)}m ago`;
    }

    // Copy path logic
    if (els.copyBtn) {
      els.copyBtn.addEventListener("click", () => {
        const text = els.outPath.textContent;
        if (text && text !== "--") {
          navigator.clipboard.writeText(text).then(() => {
            const originalText = els.copyBtn.textContent;
            els.copyBtn.textContent = "COPIED!";
            setTimeout(() => els.copyBtn.textContent = originalText, 2000);
          });
        }
      });
    }
    if (els.copyErrorBtn) {
      els.copyErrorBtn.addEventListener("click", () => {
        const summary = els.pipelineErrorSummary ? els.pipelineErrorSummary.textContent : "";
        const traceback = els.pipelineTraceback ? els.pipelineTraceback.textContent : "";
        const text = [summary, traceback].filter(Boolean).join("\n\n");
        if (text) {
          navigator.clipboard.writeText(text).then(() => {
            const originalText = els.copyErrorBtn.textContent;
            els.copyErrorBtn.textContent = "Copied!";
            setTimeout(() => els.copyErrorBtn.textContent = originalText, 2000);
          });
        }
      });
    }

    // Whole sidebar column: collapse to narrow left strip so main area expands; collapsed by default; auto-expand on error
    const dashboardEl = document.getElementById("dashboard");
    const sidebarColumnEl = document.getElementById("sidebarColumn");
    const sidebarToggleBtn = document.getElementById("sidebarToggleBtn");

    function isSidebarColumnExpanded() {
      return sidebarColumnEl && !sidebarColumnEl.classList.contains("collapsed");
    }
    function setSidebarColumnExpanded(expanded) {
      if (!dashboardEl || !sidebarColumnEl) return;
      dashboardEl.classList.toggle("sidebar-collapsed", !expanded);
      sidebarColumnEl.classList.toggle("collapsed", !expanded);
      if (sidebarToggleBtn) {
        sidebarToggleBtn.textContent = expanded ? "‚óÄ" : "‚ñ∂";
        sidebarToggleBtn.title = expanded ? "Collapse sidebar (expand main area)" : "Expand sidebar";
        sidebarToggleBtn.setAttribute("aria-label", expanded ? "Collapse sidebar" : "Expand sidebar");
      }
    }
    function expandSidebarColumn() {
      setSidebarColumnExpanded(true);
    }
    function toggleSidebarColumn() {
      setSidebarColumnExpanded(!isSidebarColumnExpanded());
    }
    if (sidebarToggleBtn) {
      sidebarToggleBtn.addEventListener("click", toggleSidebarColumn);
    }
    // Start collapsed (dashboard and aside already have collapsed classes in HTML)
    setSidebarColumnExpanded(false);

    function renderPhases(data) {
      if (!data || !data.phases) return;

      els.jobId.textContent = data.job_id || "--";
      els.workflowName.textContent = data.workflow || "--";

      // Show pipeline PID when present (debugging: ps -p <PID> to see if process is still running)
      if (els.pipelinePid) {
        if (data.pid != null && data.pid !== undefined) {
          els.pipelinePid.textContent = "PID: " + data.pid;
          els.pipelinePid.style.display = "";
        } else {
          els.pipelinePid.style.display = "none";
        }
      }

      // Show "Generating‚Ä¶" when any phase is running; show "Last update: X ago" so user can tell if it's stuck
      const anyRunning = data.phases && Object.values(data.phases).some(v => v === "running");
      const updatedTs = data.updated_ts ? new Date(data.updated_ts).getTime() : 0;
      const secondsAgo = updatedTs ? Math.round((Date.now() - updatedTs) / 1000) : 0;
      const stale = anyRunning && secondsAgo >= STALE_THRESHOLD_SEC;
      const staleMinutes = secondsAgo >= 60 ? Math.floor(secondsAgo / 60) : 0;
      const timeStr = formatTimeAgo(data.updated_ts);
      if (els.updated) {
        els.updated.textContent = stale ? "‚ö† Stuck? Last update: " + timeStr : "Last update: " + timeStr;
        els.updated.classList.toggle("stale", stale);
      }
      if (els.generatingStatus) {
        if (anyRunning) {
          // Why stuck: the pipeline writes _progress.json every ~30s via a background heartbeat. If the process exits or crashes, the heartbeat stops, so "Last update" freezes. A phase still showing RUNNING with no update for 2+ min usually means the run already exited ‚Äî check the terminal.
          const staleMsg = stale
            ? (staleMinutes >= 60
              ? "Pipeline likely exited ‚Äî no update for " + staleMinutes + "m (heartbeat stops when the process exits). Re-run the pipeline and check the terminal for errors."
              : "No update for " + (staleMinutes ? staleMinutes + "m" : secondsAgo + "s") + " ‚Äî check terminal (process may have exited).")
            : "";
          const ageHint = "Last update: " + timeStr + " ‚Äî " + (stale ? "check terminal" : "updates every ~30s when active");
          els.generatingStatus.innerHTML = '<span class="generating-line"><span class="spinner">‚óê</span> Generating‚Ä¶</span>' +
            '<span class="updated-hint">' + ageHint + '</span>' +
            (staleMsg ? '<span class="stale-warning">' + staleMsg + '</span>' : '');
        } else {
          els.generatingStatus.innerHTML = '';
        }
      }

      // Show pipeline error / traceback when present (written by generator on exception)
      const hasError = data.error || data.traceback;
      const anyPhaseError = data.phases && Object.values(data.phases).some(function(s) {
        const t = (String(s || "")).toLowerCase();
        return t === "error" || t === "failed";
      });
      if (hasError || anyPhaseError) expandSidebarColumn();
      if (els.pipelineErrorCard) {
        els.pipelineErrorCard.style.display = hasError ? "block" : "none";
        if (hasError) {
          if (els.pipelineErrorSummary) els.pipelineErrorSummary.textContent = data.error || "Pipeline failed.";
          if (els.pipelineTraceback) {
            els.pipelineTraceback.textContent = data.traceback || "";
            els.pipelineTraceback.style.display = (data.traceback && data.traceback.trim()) ? "block" : "none";
          }
        }
      }

      // Show "Story building in progress" when director is running so user knows content is being generated
      const directorRunning = data.phases && data.phases.director === "running";
      if (els.storyBuildingInfo) {
        els.storyBuildingInfo.classList.toggle("visible", !!directorRunning);
      }

      if (data.story_path && els.outPath) {
        els.outPath.textContent = data.story_path;
        els.outPath.title = "Click to copy: " + data.story_path;
      }

      const order = (data.phase_order && data.phase_order.length) ? data.phase_order : Object.keys(data.phases);
      const phaseProgress = data.phase_progress || {};

      const html = order.map(key => {
        const status = data.phases[key] || "pending";
        const label = key.toUpperCase().replace(/_/g, " ");
        const progress = phaseProgress[key];
        const complete = progress && typeof progress.complete === "number" ? progress.complete : null;
        const total = progress && typeof progress.total === "number" ? progress.total : null;
        const progressText = (complete != null && total != null && total > 0)
          ? (status === "running" ? `${complete}/${total} complete` : `${complete}/${total}`)
          : "";

        let icon = "‚óã";
        let iconClass = "phase-icon";

        if (status === "done") {
          icon = "‚óè";
        } else if (status === "running") {
          icon = "‚óê";
          iconClass += " spinner"; // Spin the icon
        }

        const badgeClass = `status-badge ${status}`;
        const statusLabel = progressText ? `${status} ¬∑ ${progressText}` : status;

        // Add a pulsing effect to the running item
        const itemClass = `phase-item ${status} ${status === 'running' ? 'blink-border' : ''}`;

        return `
                <div class="${itemClass}">
                    <div class="${iconClass}">${icon}</div>
                    <div class="phase-name">${label}</div>
                    <div class="${badgeClass}">${statusLabel}</div>
                </div>
            `;
      }).join("");

      els.phases.innerHTML = html;
    }

    /** Build metadata cell HTML from asset params. Returns { html, title } for optional tooltip. */
    function buildMetadataCell(params) {
      if (!params || !Object.keys(params).length) return { html: '<span style="color:#333;">‚Äî</span>', title: "" };
      const entries = Object.entries(params)
        .filter(([_, v]) => v !== null && v !== "" && v !== undefined);
      const html = entries.map(([k, v]) => {
        const { html: valFormatted, isBlock } = formatParamValue(k, v);
        const rowStyle = isBlock
          ? "display:block; margin-top:6px;"
          : "display:flex; gap:6px; align-items:baseline; margin-top:3px; font-size:0.75rem; line-height:1.4;";
        const keyStyle = "color:rgba(0,236,255,0.35); font-size:0.68rem; letter-spacing:0.03em; flex-shrink:0;";
        const valueStyle = isBlock
          ? "color:#aaa; margin-top:3px; line-height:1.4; display:block; font-size:0.75rem;"
          : "color:#aaa; word-break:break-word; overflow-wrap:break-word;";
        return `<div style="${rowStyle}"><span style="${keyStyle}">${escapeHtml(k)}:</span><span style="${valueStyle}">${valFormatted}</span></div>`;
      }).join("");
      const title = entries.map(([k, v]) => k + ": " + (typeof v === "string" ? v : JSON.stringify(v))).join("\n");
      return { html, title };
    }

    /** Build Output column cell HTML for an asset (image thumbnail, audio controls, or ‚Äî). base is progress URL base (no trailing slash). */
    function buildOutputCell(a, base) {
      const r = a.result_path || a.resultPath;
      if (!r) return "‚Äî";
      const pathNorm = r.replace(/\\/g, "/");
      const url = (base ? base.replace(/\/$/, "") + "/" : "") + pathNorm;
      const type = (a.type || "").toLowerCase();
      if (type === "image") return `<img src="${escapeAttr(url)}" alt="" style="max-width:120px; max-height:80px; object-fit:contain;" loading="lazy" onclick="openLightbox(this.src, 'image', event)">`;
      if (type === "audio") return `<audio controls src="${escapeAttr(url)}" style="max-width:200px;" onclick="openLightbox(this.src, 'audio', event)"></audio>`;
      if (type === "video") return `<video controls src="${escapeAttr(url)}" style="max-width:160px; max-height:90px;" onclick="openLightbox(this.src, 'video', event)"></video>`;
      return escapeHtml(r);
    }

    /** Render a list of assets (story/chapter/scene) as a table: Name | Why | Metadata | Status | Output. */
    function renderAssetsList(assets, listId, progressBaseUrl) {
      if (!assets || !assets.length) return { html: "", badge: "" };
      const base = progressBaseUrl || "";
      let html = `<div class="shot-list" style="display:none;" id="${listId}">`;
      html += `<table class="assets-table"><thead><tr><th class="col-expand" title="Expand/collapse row">‚ãÆ</th><th class="col-name">Name</th><th class="col-workflow">Workflow</th><th class="col-why">Why</th><th class="col-meta">Metadata</th><th class="col-status">Status</th><th class="col-output">Output</th></tr></thead><tbody>`;
      html += assets.map((a, idx) => {
        const name = a.asset_name || a.assetName || "(unnamed)";
        const type = a.type || "unknown";
        const workflow = a.workflow || "";
        const status = a.status || "pending";
        const params = a.params || {};
        const skillReason = (a.skill_reason || "").replace(/\s+/g, " ").trim();
        const { html: metaHtml, title: metaTitle } = buildMetadataCell(params);
        const nameCell = `<div class="name-inner"><div class="shot-icon" title="${escapeAttr(type)}">${shapeHtml(type)}</div><span>${escapeHtml(name)}</span></div>`;
        const nameTitle = name || "";
        const workflowCell = workflow ? `<span class="workflow-id" title="${escapeAttr(workflow)}">${escapeHtml(workflow)}</span>` : "‚Äî";
        const whyCell = skillReason
          ? `<span class="asset-cell-truncate" title="${escapeAttr(skillReason)}">${escapeHtml(skillReason)}</span>`
          : "‚Äî";
        const whyTitleAttr = skillReason ? "" : ` title="No reason"`;
        const outputCell = buildOutputCell(a, base);
        const outputPathRaw = a.result_path || a.resultPath;
        const outputTitle = outputPathRaw ? outputPathRaw.replace(/\\/g, "/") : "No output";
        const metaTitleAttr = metaTitle ? ` title="${escapeAttr(metaTitle)}"` : "";
        const nameTitleAttr = nameTitle ? ` title="${escapeAttr(nameTitle)}"` : "";
        const workflowTitleAttr = workflow ? ` title="${escapeAttr(workflow)}"` : "";
        const statusTitleAttr = ` title="${escapeAttr(status)}"`;
        const outputTitleAttr = ` title="${escapeAttr(outputTitle)}"`;
        const rowKey = escapeAttr(listId + ":" + idx);
        const expandBtn = `<button type="button" class="row-expand-btn" onclick="toggleRowExpand(this)" title="Expand row (show full text)">+</button>`;
        return `<tr data-row-key="${rowKey}"><td class="col-expand">${expandBtn}</td><td class="col-name"${nameTitleAttr}>${nameCell}</td><td class="col-workflow"${workflowTitleAttr}>${workflowCell}</td><td class="col-why"${whyTitleAttr}>${whyCell}</td><td class="col-meta"${metaTitleAttr}><div class="shot-prompt">${metaHtml}</div></td><td class="col-status"${statusTitleAttr}>${statusBadgeHtml(status)}</td><td class="col-output"${outputTitleAttr}>${outputCell}</td></tr>`;
      }).join("");
      html += "</tbody></table></div>";
      const assetTypeLabel = listId === "story-assets" ? "STORY" : listId.startsWith("chapter-assets") ? "CHAPTER" : "ASSETS";
      const badge = `<button class="toggle-shots-btn" data-panel-id="${listId}" data-asset-count="${assets.length}" data-asset-type="${assetTypeLabel}" onclick="togglePanel('${listId}')">[ + ] SHOW ${assets.length} ${assetTypeLabel} ASSETS</button>`;
      return { html, badge };
    }

    /** Find first chapter index that has any pending/running asset (for "working" animation). */
    function getWorkingChapterIndex(chapters) {
      if (!chapters || !chapters.length) return -1;
      for (let ci = 0; ci < chapters.length; ci++) {
        const scenes = chapters[ci].scenes || [];
        for (const s of scenes) {
          const assets = s.assets || [];
          if (assets.some(a => { const s = (a.status || "").toLowerCase(); return s === "pending" || s === "running" || s === "generating"; }))
            return ci;
        }
      }
      return -1;
    }

    const EXPANDED_STORAGE_KEY = "progress_viewer_expanded";
    function getStoredExpandedIds() {
      try {
        const raw = sessionStorage.getItem(EXPANDED_STORAGE_KEY);
        if (!raw) return new Set();
        const arr = JSON.parse(raw);
        return Array.isArray(arr) ? new Set(arr) : new Set();
      } catch (_) { return new Set(); }
    }
    function saveExpandedIds(ids) {
      try { sessionStorage.setItem(EXPANDED_STORAGE_KEY, JSON.stringify([...ids])); } catch (_) {}
    }

    /** Expanded asset table rows (panelId:rowIndex) so auto-refresh doesn't collapse the row you're viewing. */
    const EXPANDED_ROWS_STORAGE_KEY = "progress_viewer_expanded_rows";
    function getStoredExpandedRows() {
      try {
        const raw = sessionStorage.getItem(EXPANDED_ROWS_STORAGE_KEY);
        if (!raw) return new Set();
        const arr = JSON.parse(raw);
        return Array.isArray(arr) ? new Set(arr) : new Set();
      } catch (_) { return new Set(); }
    }
    function saveExpandedRows(keys) {
      try { sessionStorage.setItem(EXPANDED_ROWS_STORAGE_KEY, JSON.stringify([...keys])); } catch (_) {}
    }
    function captureExpandedRows() {
      const keys = new Set();
      if (els.storyBoard) {
        els.storyBoard.querySelectorAll("tr.row-expanded[data-row-key]").forEach(tr => {
          const k = tr.getAttribute("data-row-key");
          if (k) keys.add(k);
        });
      }
      return keys;
    }
    function restoreExpandedRows() {
      getStoredExpandedRows().forEach(key => {
        const tr = els.storyBoard && els.storyBoard.querySelector(`tr[data-row-key="${key}"]`);
        if (!tr) return;
        tr.classList.add("row-expanded");
        const btn = tr.querySelector(".row-expand-btn");
        if (btn) { btn.textContent = "‚àí"; btn.title = "Collapse row"; }
      });
    }
    /** Capture which asset panels are expanded (all .shot-list with id) for restore after re-render or page refresh. */
    function captureExpandedShots() {
      const expanded = new Set();
      if (els.storyBoard) {
        els.storyBoard.querySelectorAll(".shot-list[id]").forEach(el => {
          if (el.id && window.getComputedStyle(el).display !== "none") expanded.add(el.id);
        });
      }
      return expanded;
    }
    function restoreExpandedShots(expanded) {
      const merged = new Set(expanded);
      getStoredExpandedIds().forEach(id => merged.add(id));
      merged.forEach(id => {
        const el = document.getElementById(id);
        if (el) el.style.display = "block";
      });
      merged.forEach(id => updateToggleButtonLabel(id));
    }
    /** Update toggle button label to match panel visibility (SHOW vs HIDE). */
    function updateToggleButtonLabel(panelId) {
      const el = document.getElementById(panelId);
      const btn = document.querySelector(`.toggle-shots-btn[data-panel-id="${panelId}"]`);
      if (!btn || !el) return;
      const isExpanded = el.style.display !== "none";
      const count = btn.getAttribute("data-asset-count") || "0";
      const type = btn.getAttribute("data-asset-type") || "ASSETS";
      btn.textContent = isExpanded ? `[ ‚àí ] HIDE ${count} ${type} ASSETS` : `[ + ] SHOW ${count} ${type} ASSETS`;
    }
    /** Toggle a panel and persist expanded state so refresh doesn't collapse sections. */
    function togglePanel(id) {
      const el = document.getElementById(id);
      if (!el) return;
      el.style.display = el.style.display === "none" ? "block" : "none";
      updateToggleButtonLabel(id);
      const expanded = captureExpandedShots();
      saveExpandedIds(expanded);
    }

    /** Toggle row expand/collapse to show full truncated text for debugging. */
    function toggleRowExpand(btn) {
      const tr = btn && btn.closest ? btn.closest("tr") : null;
      if (!tr) return;
      const expanded = tr.classList.toggle("row-expanded");
      btn.textContent = expanded ? "‚àí" : "+";
      btn.title = expanded ? "Collapse row" : "Expand row (show full text)";
      const keys = captureExpandedRows();
      saveExpandedRows(keys);
    }

    function renderStory(d, progressData, progressBaseUrl) {
      const base = progressBaseUrl || "";
      if (!d || (!d.title && !d.chapters)) {
        const directorRunning = progressData && progressData.phases && progressData.phases.director === "running";
        const msg = directorRunning
          ? 'Director working‚Ä¶ Title and chapters will appear here as they‚Äôre generated.'
          : 'No story data available yet...';
        const debugBanner = (d && d.debug_mode)
          ? `<div class="debug-banner"><strong>DEBUG is on.</strong> ${escapeHtml(d.debug_mode_note || "To turn off: set debug_mode to false in config.json, or set env MP_AUTO_GENERATE_DEBUG=0")}</div>`
          : "";
        els.storyBoard.innerHTML = debugBanner + `<div style="padding:2rem;color:var(--text-secondary);">${msg}</div>`;
        return;
      }

      const expandedShots = captureExpandedShots();
      saveExpandedIds(expandedShots);
      const expandedRows = captureExpandedRows();
      saveExpandedRows(expandedRows);

      const title = escapeHtml(d.title || "Untitled Story");
      const logline = escapeHtml(d.logline || "No logline generated yet.");
      const directorRunning = progressData && progressData.phases && progressData.phases.director === "running";
      const workingChapterIndex = getWorkingChapterIndex(d.chapters);

      // Assets Summary
      const assets = d.assets_by_type || {};
      const assetHtml = ["image", "audio", "video", "text"].map(type => `
            <div class="asset-stat">
                <div class="asset-shape-wrap">${shapeHtml(type)}</div>
                <span class="asset-val">${assets[type] || 0}</span>
                <span class="asset-label">${type}s</span>
            </div>
        `).join("");

      // Story-level assets section
      const storyAssets = d.story_assets || [];
      const storyAssetsRendered = renderAssetsList(storyAssets, "story-assets", base);
      const storyAssetsSection = storyAssets.length > 0
        ? `<div class="card-title" style="margin-top:1rem;">Story assets</div><div style="margin-bottom:1rem;">${storyAssetsRendered.badge}${storyAssetsRendered.html}</div>`
        : "";

      // Chapters rendered as Screenplay (with chapter assets before scenes)
      // Strip leading "Chapter N" from API title so we don't show "Chapter 03: Chapter 2 - The Invitation"
      const stripChapterPrefix = (t) => (t || "").replace(/^Chapter\s*\d+\s*[-:]\s*/i, "").trim() || t;
      const chaptersHtml = (d.chapters || []).map((c, i) => {
        const chapterNum = String(i + 1).padStart(2, "0");
        const rawTitle = c.title || `Chapter ${i + 1}`;
        const cTitle = escapeHtml(stripChapterPrefix(rawTitle) || rawTitle);
        const isWorking = directorRunning && workingChapterIndex === i;
        const scenes = c.scenes || [];
        const chapterAssets = c.assets || [];
        const chapterAssetsRendered = renderAssetsList(chapterAssets, "chapter-assets-" + i, base);
        const chapterAssetsSection = chapterAssets.length > 0
          ? `<div class="card-title" style="margin:1rem 0 0.5rem 0; font-size:0.9rem;">Chapter assets</div><div style="margin-bottom:1rem;">${chapterAssetsRendered.badge}${chapterAssetsRendered.html}</div>`
          : "";

        const scenesHtml = scenes.map((s, si) => {
          const sName = escapeHtml(s.name || `Scene ${si + 1}`);
          const sSummary = escapeHtml(s.summary || "");
          const sAssets = s.assets_by_type || {};

          // Format summary as Action or simple text if it lacks structure
          // Try to parse rudimentary character/dialogue if present (simple heuristic)
          // For now, treat summary as Action Block

          const assetsList = s.assets || [];
          const hasPendingOrRunning = assetsList.some(a => {
            const st = (a.status || "").toLowerCase();
            return st === "pending" || st === "running" || st === "generating";
          });
          const sceneWorking = directorRunning && hasPendingOrRunning;
          let shotsHtml = "";

          if (assetsList.length > 0) {
            const panelId = "shots-" + i + "-" + si;
            shotsHtml = `<div class="shot-list" style="display:none;" id="${panelId}">`;
            shotsHtml += `<table class="assets-table"><thead><tr><th class="col-expand" title="Expand/collapse row">‚ãÆ</th><th class="col-name">Name</th><th class="col-workflow">Workflow</th><th class="col-why">Why</th><th class="col-meta">Metadata</th><th class="col-status">Status</th><th class="col-output">Output</th></tr></thead><tbody>`;
            shotsHtml += assetsList.map((a, ai) => {
              const name = a.asset_name || a.assetName || "(unnamed)";
              const type = a.type || "unknown";
              const workflow = a.workflow || "";
              const status = a.status || "pending";
              const params = a.params || {};
              const skillReason = (a.skill_reason || "").replace(/\s+/g, " ").trim();
              const { html: metaHtml, title: metaTitle } = buildMetadataCell(params);
              const nameCell = `<div class="name-inner"><div class="shot-icon" title="${escapeAttr(type)}">${shapeHtml(type)}</div><span>${escapeHtml(name)}</span></div>`;
              const nameTitle = name || "";
              const workflowCell = workflow ? `<span class="workflow-id" title="${escapeAttr(workflow)}">${escapeHtml(workflow)}</span>` : "‚Äî";
              const whyCell = skillReason
                ? `<span class="asset-cell-truncate" title="${escapeAttr(skillReason)}">${escapeHtml(skillReason)}</span>`
                : "‚Äî";
              const whyTitleAttr = skillReason ? "" : ` title="No reason"`;
              const outputCell = buildOutputCell(a, base);
              const outputPathRaw = a.result_path || a.resultPath;
              const outputTitle = outputPathRaw ? outputPathRaw.replace(/\\/g, "/") : "No output";
              const metaTitleShort = metaTitle.length > 400 ? metaTitle.slice(0, 400) + "‚Ä¶" : metaTitle;
              const metaTitleAttr = metaTitle ? ` title="${escapeAttr(metaTitleShort)}"` : "";
              const nameTitleAttr = nameTitle ? ` title="${escapeAttr(nameTitle)}"` : "";
              const workflowTitleAttr = workflow ? ` title="${escapeAttr(workflow)}"` : "";
              const statusTitleAttr = ` title="${escapeAttr(status)}"`;
              const outputTitleAttr = ` title="${escapeAttr(outputTitle)}"`;
              const rowKey = escapeAttr(panelId + ":" + ai);
              const expandBtn = `<button type="button" class="row-expand-btn" onclick="toggleRowExpand(this)" title="Expand row (show full text)">+</button>`;
              return `<tr data-row-key="${rowKey}"><td class="col-expand">${expandBtn}</td><td class="col-name"${nameTitleAttr}>${nameCell}</td><td class="col-workflow"${workflowTitleAttr}>${workflowCell}</td><td class="col-why"${whyTitleAttr}>${whyCell}</td><td class="col-meta"${metaTitleAttr}><div class="shot-prompt">${metaHtml}</div></td><td class="col-status"${statusTitleAttr}>${statusBadgeHtml(status)}</td><td class="col-output"${outputTitleAttr}>${outputCell}</td></tr>`;
            }).join("");
            shotsHtml += "</tbody></table></div>";
          }

          const assetCountBadge = assetsList.length > 0
            ? `<button class="toggle-shots-btn" data-panel-id="shots-${i}-${si}" data-asset-count="${assetsList.length}" data-asset-type="SCENE" onclick="togglePanel('shots-${i}-${si}')">[ + ] SHOW ${assetsList.length} SCENE ASSETS</button>`
            : "";

          return `
             <div class="screenplay-scene ${sceneWorking ? "scene-working" : ""}">
               <div class="sp-slugline">${sName.toUpperCase()}${sceneWorking ? '<span class="scene-working-badge"><span class="spinner">‚óê</span> Generating‚Ä¶</span>' : ""}</div>
               <div class="sp-action">${sSummary}</div>
               <div style="display:flex; flex-direction:column; align-items:flex-end; margin-bottom:1rem;">
                  <div style="display:flex; gap:8px; opacity:0.7;">
                      ${Object.entries(sAssets).map(([k, v]) => v > 0 ? `<span class="mini-badge has-assets" style="border-style:dashed;">${k}:${v}</span>` : '').join('')}
                  </div>
                  ${assetCountBadge}
                  ${shotsHtml}
               </div>
             </div>
           `;
        }).join("");

        return `
            <div class="screenplay-chapter ${isWorking ? "chapter-working" : ""}">
                <div class="screenplay-chapter-title">
                    Chapter ${chapterNum}: ${cTitle}
                    ${isWorking ? '<span class="chapter-working-badge"><span class="spinner">‚óê</span> Generating‚Ä¶</span>' : ""}
                </div>
                ${chapterAssetsSection}
                ${scenesHtml}
            </div>
        `;
      }).join("");

      const debugBannerHtml = (d.debug_mode)
        ? `<div class="debug-banner"><strong>DEBUG is on.</strong> ${escapeHtml(d.debug_mode_note || "To turn off: set debug_mode to false in config.json, or set env MP_AUTO_GENERATE_DEBUG=0")}</div>`
        : "";

      els.storyBoard.innerHTML = `
            ${debugBannerHtml}
            <div class="story-title-large" style="text-align:center; margin-bottom:0.5rem;">${title}</div>
            <div class="logline" style="text-align:center; border:none; font-style:normal; font-family:'Courier New'; margin-bottom: 2rem;">
                "${logline}"
            </div>
            ${storyAssetsSection}
            <div class="asset-grid">
                ${assetHtml}
            </div>

            <div class="card-title" style="margin-top: 2rem;">Screenplay</div>
            <div class="screenplay-container">
                ${chaptersHtml || '<div style="text-align:center; padding:2rem; color:#666;">(SCENES NOT YET WRITTEN)</div>'}
            </div>
        `;
      restoreExpandedShots(expandedShots);
      restoreExpandedRows();
    }

    const fetchOpts = { cache: "no-store" };
    // Base URL for progress API: when page is not served from progress server (e.g. embedded in IDE), relative fetches fail; use explicit origin.
    const PROGRESS_PORT = "8081";
    const STALE_THRESHOLD_SEC = 120; // 2 minutes ‚Äî no update for this long is usually a sign to investigate; shows warning and error sound

    /**
     * Sound rules (page polls every 2s):
     * 1. Story-finish sound: once when director phase goes running ‚Üí done.
     * 2. Progress sound: when phases change OR when director content changes. Not on heartbeat.
     * 3. Error sound: once when connection lost, first time stale, or phase error/failed.
     */
    const MUTE_STORAGE_KEY = "progress_viewer_mute";
    function isMuted() {
      try { return localStorage.getItem(MUTE_STORAGE_KEY) === "1"; } catch (_) { return false; }
    }
    function setMuted(muted) {
      try { localStorage.setItem(MUTE_STORAGE_KEY, muted ? "1" : "0"); } catch (_) {}
    }

    /** Play story-progress sound when new chapters/scenes/assets or phase progress is detected. */
    function playProgressSound() {
      if (isMuted()) return;
      try {
        const audio = new Audio("notification-story-progress.mp3");
        audio.volume = 0.6;
        audio.play().catch(function() {});
      } catch (_) {}
    }

    /** Play story-finish sound when story build (director phase) completes. */
    function playStoryFinishSound() {
      if (isMuted()) return;
      try {
        const audio = new Audio("notification-story-finish.mp3");
        audio.volume = 0.6;
        audio.play().catch(function() {});
      } catch (_) {}
    }

    /** Play error sound when connection is broken, no update for long time, or a phase has failed. */
    function playErrorSound() {
      if (isMuted()) return;
      try {
        const audio = new Audio("notification-error.mp3");
        audio.volume = 0.6;
        audio.play().catch(function() {});
      } catch (_) {}
    }

    function updateMuteButton() {
      const btn = document.getElementById("muteToggle");
      if (!btn) return;
      const muted = isMuted();
      btn.textContent = muted ? "üîá Muted" : "üîä Sound on";
      btn.setAttribute("aria-pressed", muted ? "true" : "false");
      btn.classList.toggle("muted", muted);
    }
    (function initMuteToggle() {
      updateMuteButton();
      const btn = document.getElementById("muteToggle");
      if (btn) {
        btn.addEventListener("click", function() {
          setMuted(!isMuted());
          updateMuteButton();
        });
      }
    })();

    /** Fingerprint of progress state (full: phases + updated_ts). */
    let lastProgressFingerprint = null;
    /** Phase-only fingerprint so we don't play progress sound on heartbeat (updated_ts every 30s). */
    let lastPhaseFingerprint = null;
    /** Fingerprint of director/story content: new chapters, scenes, scene details, or assets trigger sound. */
    let lastDirectorFingerprint = null;
    /** Previous director phase status to detect transition to "done" (story build finished). */
    let lastDirectorPhaseStatus = null;
    /** When we first saw director "running" (ms), for story-build duration. */
    let lastDirectorStartedAt = null;
    /** Computed story build duration in ms (director running ‚Üí done); shown until page reload. */
    let storyBuildDurationMs = null;
    /** Previous connection status for error sound when connection is lost. */
    let lastConnectionStatus = null;
    /** Previous stale state so we play error sound only when first becoming stale. */
    let lastStale = false;
    /** Whether any phase was in error/failed last poll (for generation-failed sound). */
    let lastPhaseHadError = false;

    /** Build a fingerprint of director content so we can play sound when new chapters, scenes, details, or assets appear. */
    function directorContentFingerprint(d) {
      if (!d || (!d.title && !(d.chapters && d.chapters.length))) return null;
      const chapters = (d.chapters || []).map(function(c) {
        const scenes = (c.scenes || []).map(function(s) {
          const assets = (s.assets || []).map(function(a) {
            return (a.asset_name || a.assetName || "").trim() + "|" + (a.status || "");
          }).sort();
          return { name: s.name || "", summaryLen: (s.summary || "").length, assets: assets };
        });
        const cAssets = (c.assets || []).map(function(a) {
          return (a.asset_name || a.assetName || "").trim() + "|" + (a.status || "");
        }).sort();
        return { title: c.title || "", scenes: scenes, assets: cAssets };
      });
      const storyAssets = (d.story_assets || []).map(function(a) {
        return (a.asset_name || a.assetName || "").trim() + "|" + (a.status || "");
      }).sort();
      return JSON.stringify({
        title: d.title || "",
        loglineLen: (d.logline || "").length,
        storyAssets: storyAssets,
        chapters: chapters
      });
    }

    /** Format milliseconds as "Xm Ys", "Xs", or "Xh Ym Zs". */
    function formatDuration(ms) {
      if (ms == null || ms < 0) return "";
      const s = Math.floor(ms / 1000);
      if (s < 60) return s + "s";
      const m = Math.floor(s / 60);
      const sec = s % 60;
      if (m < 60) return sec > 0 ? m + "m " + sec + "s" : m + "m";
      const h = Math.floor(m / 60);
      const min = m % 60;
      return (min > 0 || sec > 0) ? h + "h " + min + "m " + sec + "s" : h + "h";
    }

    const progressBase = (function() {
      const params = new URLSearchParams(window.location.search);
      if (params.get("progressBase")) return params.get("progressBase").replace(/\/$/, "");
      // Use same-origin (relative) whenever the viewer is served from the progress port so API and asset URLs (images/video/audio) load from the same host (works in production e.g. https://server:8081).
      if (window.location.port === PROGRESS_PORT) return "";
      return "http://127.0.0.1:" + PROGRESS_PORT;
    })();
    // #region agent log
    const DEBUG_INGEST = "http://127.0.0.1:7247/ingest/ca26efc6-4865-45e1-a109-8ee75418b9c5";
    function agentLog(location, message, data, hypothesisId) {
      fetch(DEBUG_INGEST, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ location, message, data: data || {}, hypothesisId, timestamp: Date.now() }) }).catch(function() {});
    }
    // #endregion

    function cacheBuster() { return "_=" + Date.now(); }
    async function poll() {
      try {
        const progressUrl = progressBase + "/_progress.json?" + cacheBuster();
        const r1 = await fetch(progressUrl, fetchOpts);
        if (r1.ok) {
          const data = await r1.json();
          const directorStatus = data.phases && data.phases.director;
          if (directorStatus === "running" && lastDirectorStartedAt === null) {
            lastDirectorStartedAt = Date.now();
          }
          const storyJustFinished = lastDirectorPhaseStatus === "running" && directorStatus === "done";
          if (storyJustFinished) {
            playStoryFinishSound();
            if (lastDirectorStartedAt !== null) {
              storyBuildDurationMs = Date.now() - lastDirectorStartedAt;
              lastDirectorStartedAt = null;
            }
          }
          lastDirectorPhaseStatus = directorStatus || null;
          const phaseFingerprint = JSON.stringify(data.phases);
          const fullFingerprint = JSON.stringify({ phases: data.phases, updated_ts: data.updated_ts });
          if (!storyJustFinished && lastProgressFingerprint !== null && phaseFingerprint !== lastPhaseFingerprint) {
            playProgressSound();
          }
          lastProgressFingerprint = fullFingerprint;
          lastPhaseFingerprint = phaseFingerprint;
          // Error cues: no update for long time (stale), or any phase failed/error
          const anyRunning = data.phases && Object.values(data.phases).some(function(v) { return v === "running"; });
          const updatedTs = data.updated_ts ? new Date(data.updated_ts).getTime() : 0;
          const secondsAgo = updatedTs ? Math.round((Date.now() - updatedTs) / 1000) : 0;
          const stale = anyRunning && secondsAgo >= STALE_THRESHOLD_SEC;
          const anyPhaseError = data.phases && Object.values(data.phases).some(function(s) {
            const t = (s || "").toLowerCase();
            return t === "error" || t === "failed";
          });
          if (lastStale === false && stale === true) playErrorSound();
          if (lastPhaseHadError === false && anyPhaseError === true) playErrorSound();
          lastStale = stale;
          lastPhaseHadError = !!anyPhaseError;
          lastConnectionStatus = "CONNECTED";
          // #region agent log
          agentLog("progress_viewer.html:poll", "progress_ok", { phases: data.phases, directorVal: data.phases && data.phases.director, hasDirectorKey: !!(data.phases && "director" in data.phases) }, "H1");
          // #endregion
          renderPhases(data);
          if (els.conn) { els.conn.textContent = "CONNECTED"; els.conn.style.color = "var(--success)"; }
          if (storyBuildDurationMs !== null) {
            const el = document.getElementById("storyBuildTime");
            if (el) {
              el.textContent = "Story build time: " + formatDuration(storyBuildDurationMs);
              el.style.display = "block";
            }
          }

          // Show "generating" animation on main card when any phase is running
          const mainCard = document.querySelector("#mainContent .card");
          if (mainCard) {
            const anyRunning = data.phases && Object.values(data.phases).some(v => v === "running");
            mainCard.classList.toggle("phase-generating", !!anyRunning);
          }

          // Fetch details if available
          if (data.phases && (data.phases.director === "running" || data.phases.director === "done")) {
            let directorRendered = false;
            try {
              const directorUrl = progressBase + "/_director_progress.json?" + cacheBuster();
              const r2 = await fetch(directorUrl, fetchOpts);
              // #region agent log
              agentLog("progress_viewer.html:poll", "director_fetch", { status: r2.status, ok: r2.ok }, "H2,H5");
              // #endregion
              if (r2.ok) {
                const dData = await r2.json();
                const directorFp = directorContentFingerprint(dData);
                if (directorFp !== null && lastDirectorFingerprint !== null && directorFp !== lastDirectorFingerprint) {
                  playProgressSound();
                }
                if (directorFp !== null) lastDirectorFingerprint = directorFp;
                renderStory(dData, data, progressBase);
                directorRendered = true;
              }
            } catch (e) { console.log("No director data yet", e); }
            if (!directorRendered) {
              els.storyBoard.innerHTML = '<div style="padding:2rem;color:var(--text-secondary);">Director running‚Ä¶ Story skeleton will appear here when ready. (If this persists, refresh the page.)</div>';
            }
          } else {
            // #region agent log
            agentLog("progress_viewer.html:poll", "director_branch_skipped", { directorBranch: false, phases: data.phases }, "H1");
            // #endregion
          }
        } else {
          if (lastConnectionStatus === "CONNECTED") playErrorSound();
          lastConnectionStatus = "OFFLINE";
          expandSidebarColumn();
          if (els.conn) { els.conn.textContent = "OFFLINE"; els.conn.style.color = "var(--error)"; }
        }
      } catch (e) {
        if (lastConnectionStatus === "CONNECTED") playErrorSound();
        lastConnectionStatus = "ERROR";
        expandSidebarColumn();
        if (els.conn) { els.conn.textContent = "ERROR"; els.conn.style.color = "var(--error)"; }
      }
    }

    poll();
    setInterval(poll, 2000);

    /* ‚îÄ‚îÄ Lightbox for enlarged preview images/videos ‚îÄ‚îÄ */
    function openLightbox(src, type, event) {
      event.stopPropagation();
      event.preventDefault();
      const overlay = document.createElement("div");
      overlay.className = "preview-lightbox";
      const closeBtn = document.createElement("button");
      closeBtn.className = "lightbox-close";
      closeBtn.innerHTML = "&#x2715;";
      closeBtn.onclick = function () { overlay.remove(); };
      overlay.appendChild(closeBtn);
      let media;
      if (type === "video") {
        media = document.createElement("video");
        media.src = src;
        media.controls = true;
        media.autoplay = true;
        media.loop = true;
      } else if (type === "audio") {
        media = document.createElement("audio");
        media.src = src;
        media.controls = true;
        media.autoplay = true;
      } else {
        media = document.createElement("img");
        media.src = src;
      }
      media.onclick = function (e) { e.stopPropagation(); };
      overlay.appendChild(media);
      overlay.onclick = function () { overlay.remove(); };
      document.addEventListener("keydown", function handler(e) {
        if (e.key === "Escape") {
          overlay.remove();
          document.removeEventListener("keydown", handler);
        }
      });
      document.body.appendChild(overlay);
    }

  </script>
</body>

</html>